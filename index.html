<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Hussle - Get this money, Don't get caught !</title>

  <!-- viewport optimisé mobile, notch & status bar -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="theme-color" content="#000000">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <style>
    /* Hauteur pilotée par --vh (vraie hauteur visible, fix iOS/Android) */
    html, body { height: calc(var(--vh, 1vh) * 100); }
    body {
      margin: 0; padding: 0; background: #000;
      font-family: 'vt323', cursive;
      overflow: hidden;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      -webkit-text-size-adjust: 100%;
      overscroll-behavior: none;
      /* (retiré pour ne pas décentrer le canvas)
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom); */
    }
    canvas {
      display: block;
      margin: auto;
      touch-action: none;
      max-width: 100vw;
      max-height: calc(var(--vh, 1vh) * 100);
    }
  </style>
  <script>
    // Calcule la vraie hauteur visible et la place dans --vh (évite l’espace en haut sur mobile)
    (function setVh() {
      const vh = (window.visualViewport ? window.visualViewport.height : window.innerHeight) * 0.01;
      document.documentElement.style.setProperty('--vh', `${vh}px`);
    })();
    window.addEventListener('resize', () => {
      const vh = (window.visualViewport ? window.visualViewport.height : window.innerHeight) * 0.01;
      document.documentElement.style.setProperty('--vh', `${vh}px`);
    }, { passive: true });
    window.addEventListener('orientationchange', () => {
      const vh = (window.visualViewport ? window.visualViewport.height : window.innerHeight) * 0.01;
      document.documentElement.style.setProperty('--vh', `${vh}px`);
    });
  </script>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
<script>
// ======= Réglage unique de l'espacement des lignes =======
const STATS_LINE_SPACING = 0.55;
// =========================================================

const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

// Résolution virtuelle fixe (comme PC) + FIT
const spriteScale = 1;
const hudScale = 1;
const baseButtonScale = 0.25;
const gameOverImageScale = 0.3;

const GAME_W = 400;
const GAME_H = 600;

const config = {
  type: Phaser.WEBGL,
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH,
    width: GAME_W,
    height: GAME_H
  },
  render: { antialias: true, roundPixels: true },
  physics: { default: 'arcade', arcade: { debug: false } },
  scene: [IntroScene, MainScene]
};

let game = new Phaser.Game(config);
let musicStarted = false, backMusic = null, gameOverSoundRef = null;

// Best score
let bestLocalScore = parseInt(localStorage.getItem('bestScore') || '0', 10);

// Refs
let statsContainer = null, scoreLineText = null, timeLineText = null, bestLocalText = null;
let player, cursors, obstacles, bonuses, background;
let score = 0, scoreText, levelText, levelDisplay, healthLabel, healthHearts, timerText;
let gameOverImage, finalScoreText, overlay, restartButton, supportButton;
let level = 1, lives = 3, gameOver = false;
let obstacleSpeed = 120, bonusSpeed = 200, roadScrollSpeed = 2;
let spawnObstacleEvent, spawnBonusEvent, timer = 0, timerEvent, levelTween, levelTimer;
const levelThresholds = [0, 250, 600, 1100, 1750, 2450, 3400, 4500];

/* ----- Zones et garde mobile ----- */
let mobileRetryZone = null;
let mobileSupportZone = null;
let mobileTapReady = false; // devient true seulement après avoir levé le doigt sur l'écran de fin

function supportsWebP(){ const c=document.createElement('canvas'); return !!(c.getContext && c.getContext('2d')) ? c.toDataURL('image/webp').indexOf('data:image/webp')===0 : false; }

// ---------- Intro ----------
function IntroScene(){ Phaser.Scene.call(this,{key:'IntroScene'}); }
IntroScene.prototype = Object.create(Phaser.Scene.prototype); IntroScene.prototype.constructor = IntroScene;
IntroScene.prototype.preload = function(){
  this.load.image('introWebP','image/intro.webp');
  this.load.image('introJPG','image/intro.jpg');
  this.load.image('startBtn', supportsWebP() ? 'image/start.webp' : 'image/start.png');
  this.load.audio('back','son/back.mp3');
  this.load.audio('back_intro','son/back_intro.mp3');
};
IntroScene.prototype.create = function(){
  const { width, height } = this.scale;
  const key = supportsWebP() ? 'introWebP' : 'introJPG';
  this.add.image(width/2, height/2, key).setDisplaySize(width, height);

  this.introMusic = this.sound.add('back_intro', { loop:true, volume:0.2 }); this.introMusic.play();
  const unlock = () => { this.sound.unlock(); if(!this.introMusic.isPlaying) this.introMusic.play();
    window.removeEventListener('pointerdown', unlock); window.removeEventListener('touchstart', unlock); };
  window.addEventListener('pointerdown', unlock); window.addEventListener('touchstart', unlock);

  const startButton = this.add.image(width/2, height*0.8, 'startBtn').setOrigin(0.5).setInteractive({useHandCursor:true}).setScale(baseButtonScale*spriteScale);
  this.tweens.add({ targets:startButton, scale:baseButtonScale*spriteScale*1.2, yoyo:true, repeat:-1, ease:'Sine.easeInOut', duration:600 });
  startButton.on('pointerdown', () => { if(this.introMusic?.isPlaying) this.introMusic.stop(); this.cameras.main.fadeOut(500,0,0,0);
    this.time.delayedCall(500, () => this.scene.start('MainScene')); });
};

// ---------- Main ----------
function MainScene(){ Phaser.Scene.call(this,{key:'MainScene'}); }
MainScene.prototype = Object.create(Phaser.Scene.prototype); MainScene.prototype.constructor = MainScene;

MainScene.prototype.preload = function(){
  const isRetina = window.devicePixelRatio > 1, useWebP = supportsWebP(), ext = useWebP ? 'webp' : 'png';
  this.load.image('player',`image/player${isRetina?'@2x':''}.${ext}`);
  this.load.image('obstacle',`image/obstacle${isRetina?'@2x':''}.${ext}`);
  this.load.image('bonus',`image/bonus${isRetina?'@2x':''}.${ext}`);
  this.load.image('road',`image/road${isRetina?'@2x':''}.${ext}`);
  this.load.image('vie',`image/vie${isRetina?'@2x':''}.${ext}`);
  this.load.image('retryBtn', supportsWebP() ? 'image/retry.webp' : 'image/retry.png');
  this.load.image('gameOverImg', supportsWebP() ? 'image/game_over.webp' : 'image/game_over.png');
  this.load.audio('bonus','son/bonus.wav');
  this.load.audio('obstacle','son/obstacle.wav');
  this.load.audio('gameover','son/gameover.mp3');
  this.load.audio('lvl','son/lvl.wav');
  this.load.bitmapFont('vt323','fonts/vt323_0.png','fonts/vt323.fnt');
};

MainScene.prototype.create = function(){
  const w = this.scale.width, h = this.scale.height;
  const cx = w/2, cy = h/2;

  background = this.add.tileSprite(cx, cy, w, h*2, 'road').setDepth(0);

  // Positions identiques PC
  player = this.physics.add.sprite(200,400,'player').setDisplaySize(40*spriteScale,40*spriteScale).setCollideWorldBounds(true);
  obstacles = this.physics.add.group(); bonuses = this.physics.add.group();

  scoreText = this.add.bitmapText(10,5,'vt323','SCORE: 0',28*hudScale).setDepth(11);
  timerText = this.add.bitmapText(200,5,'vt323','TEMPS: 0',28*hudScale).setOrigin(0.5,0).setDepth(11);
  levelText = this.add.bitmapText(200,50,'vt323','NIVEAU: 1',28*hudScale).setOrigin(0.5).setDepth(11);
  healthLabel = this.add.bitmapText(300,5,'vt323','VIE:',28*hudScale).setDepth(11);

  healthHearts = this.add.group(); updateHearts.call(this);
  levelDisplay = this.add.bitmapText(200,300,'vt323','',48).setOrigin(0.5).setDepth(20);
  overlay = this.add.rectangle(200,300,400,600,0x000000,0.0).setDepth(49).setVisible(false);

  gameOverImage = this.add.image(200,220,'gameOverImg').setOrigin(0.5).setDepth(50).setScale(gameOverImageScale*spriteScale).setAlpha(0).setVisible(false).disableInteractive();
  finalScoreText = this.add.bitmapText(200,340,'vt323','',36).setOrigin(0.5).setDepth(50);

  restartButton = this.add.image(200,424,'retryBtn').setOrigin(0.5).setDepth(53).setVisible(false).setInteractive({useHandCursor:true}).setScale(baseButtonScale*spriteScale);
  restartButton.on('pointerdown', () => resetGame.call(this));
  this.tweens.add({ targets:restartButton, scale:baseButtonScale*spriteScale*1.2, yoyo:true, repeat:-1, ease:'Sine.easeInOut', duration:600 });

  cursors = this.input.keyboard.createCursorKeys();
  spawnObstacleEvent = this.time.addEvent({ delay:1200, callback:spawnObstacle, callbackScope:this, loop:true });
  spawnBonusEvent = this.time.addEvent({ delay:2000, callback:spawnBonus, callbackScope:this, loop:true });
  timerEvent = this.time.addEvent({ delay:1000, callback:()=>{ timer++; timerText.setText('TEMPS: ' + timer); }, loop:true });

  this.physics.add.overlap(player, obstacles, hitObstacle, null, this);
  this.physics.add.overlap(player, bonuses, collectBonus, null, this);

  this.input.on('pointermove', p => { if(!gameOver){ player.x = p.x; player.y = p.y - 50; } });

  if (!musicStarted){ backMusic = this.sound.add('back',{ loop:true, volume:0.15 }); backMusic.play(); musicStarted = true; }
  this.bonusSound = this.sound.add('bonus',{ volume:0.15 });
  this.obstacleSound = this.sound.add('obstacle',{ volume:0.2 });
  gameOverSoundRef = this.sound.add('gameover',{ volume:0.7 });
  this.levelSound = this.sound.add('lvl',{ volume:0.5 });

  this.scale.on('resize', () => placeSupportBottom(this));
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', () => placeSupportBottom(this));
    window.visualViewport.addEventListener('scroll', () => placeSupportBottom(this));
  } else {
    window.addEventListener('resize', () => placeSupportBottom(this));
  }
};

MainScene.prototype.update = function(time, delta){
  if (gameOver) return;
  background.tilePositionY -= roadScrollSpeed * (delta/16.66);

  const move = 250;
  if (cursors.left.isDown) player.x -= move*(delta/1000); else if (cursors.right.isDown) player.x += move*(delta/1000);
  if (cursors.up.isDown) player.y -= move*(delta/1000); else if (cursors.down.isDown) player.y += move*(delta/1000);

  obstacles.children.iterate(o => { o.y += obstacleSpeed*(delta/1000); });
  bonuses.children.iterate(b => { b.y += bonusSpeed*(delta/1000); });

  obstacles.getChildren().forEach(o => { if (o.y > 560) o.destroy(); });
  bonuses.getChildren().forEach(b => { if (b.y > 560) b.destroy(); });

  obstacleSpeed = 120 + level*15; bonusSpeed = 200 + level*10;

  const nl = getLevelFromScore(score);
  if (nl !== level){
    level = nl; roadScrollSpeed = 2 + (level-1)*0.5;
    levelText.setText('NIVEAU: ' + level);
    showLevelMessage(this);
    adjustSpawnRates.call(this); // ✅ garder le scope scène
  }
  scoreText.setText('SCORE: ' + score);
};

function getLevelFromScore(s){ let l=1; for(let i=1;i<levelThresholds.length;i++){ if(s>=levelThresholds[i]) l=i+1; } return l; }
function adjustSpawnRates(){
  if (spawnBonusEvent) spawnBonusEvent.reset({
    delay: Math.max(500, 2500 - level*300),
    callback: spawnBonus,
    callbackScope: this,
    loop: true
  });
  if (spawnObstacleEvent) spawnObstacleEvent.reset({
    delay: Math.max(400, 1200 - level*100),
    callback: spawnObstacle,
    callbackScope: this,
    loop: true
  });
}
function showLevelMessage(scene){ if(scene.levelSound) scene.levelSound.play(); levelDisplay.setText('NIVEAU : ' + level);
  if(levelTween) levelTween.stop(); if(levelTimer) levelTimer.remove(false);
  levelTween = scene.tweens.add({ targets:levelDisplay, scaleX:1.5, scaleY:1.5, duration:300, yoyo:true });
  levelTimer = scene.time.addEvent({ delay:1500, callback:()=>levelDisplay.setText('') });
}
function spawnObstacle(){
  const w = this.scale.width;
  obstacles.create(Phaser.Math.Between(50, w-50), 50, 'obstacle').setDisplaySize(40*spriteScale,40*spriteScale).setDepth(1);
}
function spawnBonus(){
  const w = this.scale.width;
  bonuses.create(Phaser.Math.Between(50, w-50), 50, 'bonus').setDisplaySize(40*spriteScale,40*spriteScale).setDepth(1);
}
function collectBonus(p,b){ b.destroy(); score+=50; this.bonusSound.play(); }
function hitObstacle(p,o){ o.destroy(); lives--; this.obstacleSound.play(); updateHearts.call(this); animateHealthBar.call(this); if(lives<=0) endGame.call(this); }
function animateHealthBar(){ healthHearts.children.each(h => { this.tweens.add({ targets:h, scaleX:h.scaleX*1.15, scaleY:h.scaleY*1.15, yoyo:true, duration:150, ease:'Power2' }); }); }

/* Cœurs :
   - PC : position fixe (startX=345, spacing=19, sc=0.4, y=22)
   - Mobile : adaptatif */
function updateHearts(){
  healthHearts.clear(true,true);
  if (isMobile){
    const sc = 0.6*spriteScale, heartW = 32*sc;
    const available = this.scale.width - (healthLabel.x + healthLabel.width + 20);
    let spacing = heartW*1.1; if (lives*spacing>available) spacing = available/Math.max(1,lives);
    const startX = healthLabel.x + healthLabel.width + 10, midY = healthLabel.y + (healthLabel.height*0.5);
    for (let i=0;i<lives;i++){ let h = this.add.image(startX + (i*spacing), midY, 'vie').setOrigin(0.5).setScale(sc).setDepth(11); healthHearts.add(h); }
  } else {
    const startX=345, spacing=19, sc=0.4, y=22;
    for (let i=0;i<lives;i++){ let h = this.add.image(startX + (i*spacing), y, 'vie').setOrigin(0.5).setScale(sc).setDepth(11); healthHearts.add(h); }
  }
}

function placeSupportBottom(scene){
  if (!supportButton) return;
  const canvasH = scene.scale.height;
  const bounds = supportButton.getBounds();
  const halfH = bounds.height / 2;
  const safeMargin = 40;
  supportButton.setY(canvasH - safeMargin - halfH);
}

function endGame(){
  if (gameOver) return; gameOver = true;
  if (backMusic?.isPlaying) backMusic.stop();
  if (gameOverSoundRef) gameOverSoundRef.play();
  this.physics.pause(); player.setTint(0xff0000);
  spawnObstacleEvent.remove(false); spawnBonusEvent.remove(false);
  if (timerEvent) timerEvent.remove(false); if (levelTween) levelTween.stop(); if (levelTimer) levelTimer.remove(false);
  levelDisplay.setText(''); overlay.setVisible(true);

  const centerX = this.scale.width/2, centerY = this.scale.height/2;

  gameOverImage.setVisible(true).setPosition(200,220);
  this.tweens.add({ targets:gameOverImage, alpha:1, duration:500, ease:'Sine.easeOut' });

  restartButton.setVisible(true).setPosition(200,424);

  if (score > bestLocalScore){ bestLocalScore = score; localStorage.setItem('bestScore', String(bestLocalScore)); }

  const statsSize = 28;
  const step = Math.max(1, statsSize * STATS_LINE_SPACING);

  const scoreLineText = this.add.bitmapText(0, -step, 'vt323', 'SCORE : ' + score, statsSize).setOrigin(0.5);
  const timeLineText  = this.add.bitmapText(0, 0,     'vt323', 'TEMPS : ' + timer + 's', statsSize).setOrigin(0.5);
  const bestLocalText = this.add.bitmapText(0,  step, 'vt323', 'MEILLEUR SCORE (TOI) : ' + bestLocalScore, statsSize).setOrigin(0.5);

  const bottomOfOver = gameOverImage.y + gameOverImage.displayHeight/1.7;
  const topOfRetry   = restartButton.y - restartButton.displayHeight/2;
  const midY = (bottomOfOver + topOfRetry) / 2;

  if (statsContainer) statsContainer.destroy();
  statsContainer = this.add.container(centerX, midY, [scoreLineText, timeLineText, bestLocalText]).setDepth(50);

  if (supportButton) supportButton.destroy();
  supportButton = this.add.container(centerX, 0).setDepth(60);

  const heartScale = 0.4, gap = 8;
  const supportText = this.add.bitmapText(0,0,'vt323','SOUTENIR LE JEU',28).setOrigin(0.5);
  const heartLeft  = this.add.image(0,0,'vie').setScale(heartScale).setOrigin(0.5);
  const heartRight = this.add.image(0,0,'vie').setScale(0.4).setOrigin(0.5);

  const heartW = heartLeft.displayWidth, heartH = heartLeft.displayHeight;
  const textW  = supportText.width,     textH  = supportText.height;

  supportText.x = 0;
  heartLeft.x   = -(textW/2 + gap + heartW/2);
  heartRight.x  =  (textW/2 + gap + heartW/2);

  const vOff = (textH/2) - (heartH/2);
  heartLeft.y = vOff; heartRight.y = vOff;

  supportButton.add([heartLeft, supportText, heartRight]);
  supportButton.setSize(heartW + gap + textW + gap + heartW + 20, Math.max(textH, heartH) + 12);
  supportButton.setInteractive({ useHandCursor:true });

  this.tweens.add({ targets:[heartLeft,heartRight], scaleX:heartScale*1.15, scaleY:heartScale*1.15, yoyo:true, repeat:-1, ease:'Sine.easeInOut', duration:700, delay:(t,k,v,i)=>i*120 });

  placeSupportBottom(this);
  this.time.delayedCall(0, () => placeSupportBottom(this));

  /* ----------- Spécifique MOBILE : deux zones + garde “fresh tap” ----------- */
  if (isMobile) {
    mobileTapReady = false;
    this.input.once('pointerup', () => { mobileTapReady = true; });

    restartButton.disableInteractive();

    const retryW = restartButton.displayWidth * 1.6;
    const retryH = restartButton.displayHeight * 1.8;
    mobileRetryZone = this.add.zone(restartButton.x, restartButton.y, retryW, retryH)
      .setOrigin(0.5).setDepth(999).setInteractive();

    mobileRetryZone.on('pointerup', (pointer) => {
      if (!mobileTapReady) return;
      mobileTapReady = false;
      pointer?.event?.stopPropagation?.();
      pointer?.event?.preventDefault?.();
      resetGame.call(this);
    });

    const bandH = Math.max(120, supportButton.getBounds().height + 40);
    mobileSupportZone = this.add.zone(centerX, this.scale.height - bandH/2, this.scale.width, bandH)
      .setOrigin(0.5).setDepth(999).setInteractive();

    mobileSupportZone.on('pointerup', (pointer) => {
      if (!mobileTapReady) return;
      mobileTapReady = false;
      pointer?.event?.stopPropagation?.();
      pointer?.event?.preventDefault?.();
      const url = 'https://paypal.me/eightenergyworld';
      const w = window.open(url, '_blank', 'noopener');
      if (!w) window.location.href = url;
    });
  } else {
    supportButton.on('pointerdown', () => window.open('https://paypal.me/eightenergyworld','_blank'));
  }
}

function resetGame(){
  score=0; lives=3; level=1; timer=0; gameOver=false;
  obstacleSpeed=120; bonusSpeed=200; roadScrollSpeed=2;
  scoreText.setText('SCORE: 0'); timerText.setText('TEMPS: 0'); levelText.setText('NIVEAU: 1');
  finalScoreText.setText('');
  gameOverImage.setVisible(false).setAlpha(0); overlay.setVisible(false); restartButton.setVisible(false);

  if (mobileRetryZone) { mobileRetryZone.destroy(); mobileRetryZone = null; }
  if (mobileSupportZone) { mobileSupportZone.destroy(); mobileSupportZone = null; }
  mobileTapReady = false;

  if (supportButton){ supportButton.destroy(); supportButton=null; }
  if (statsContainer){ statsContainer.destroy(); statsContainer=null; }

  player.clearTint(); player.setPosition(200,400);
  obstacles.clear(true,true); bonuses.clear(true,true);
  this.physics.resume();
  timerEvent = this.time.addEvent({ delay:1000, callback:()=>{ timer++; timerText.setText('TEMPS: ' + timer); }, loop:true });
  spawnObstacleEvent = this.time.addEvent({ delay:1200, callback:spawnObstacle, callbackScope:this, loop:true });
  spawnBonusEvent = this.time.addEvent({ delay:2000, callback:spawnBonus, callbackScope:this, loop:true });
  updateHearts.call(this);
  if (gameOverSoundRef?.isPlaying) gameOverSoundRef.stop();
  if (backMusic) backMusic.play();

  restartButton.setInteractive({useHandCursor:true});
}
</script>
</body>
</html>
