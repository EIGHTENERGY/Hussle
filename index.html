<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Hussle - Get this money, Don't get caught !</title>

  <!-- viewport optimisé mobile, notch & status bar -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="theme-color" content="#000000">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <style>
    /* Plein écran collé en haut sur mobile (svh = small viewport height) */
    html, body {
      height: 100svh;
      height: 100dvh; /* fallback */
    }
    body {
      margin: 0; padding: 0; background: #000;
      font-family: 'vt323', cursive;
      overflow: hidden;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      -webkit-text-size-adjust: 100%;
      overscroll-behavior: none;
    }
    canvas {
      display: block;
      margin: 0 auto;     /* centré horizontalement uniquement */
      touch-action: none;
      max-width: 100vw;
      max-height: 100svh;
    }

    /* === Interstitiel (overlay) === */
    #supportInterstitial {
      position: fixed; inset: 0;
      background: #000;
      display: none;
      z-index: 999999; /* au-dessus du canvas */
    }

    /* Croix pixel art centrée en haut (PC + Mobile) — au-dessus du contenu */
    #siClose {
      position: absolute;
      top: calc(env(safe-area-inset-top, 0px) + 10px);
      left: 50%;
      transform: translateX(-50%);
      width: 32px; height: 32px;
      background: transparent;
      border: none;
      cursor: pointer;
      touch-action: manipulation;
      z-index: 2;
    }
    #siClose::before,
    #siClose::after {
      content: '';
      position: absolute;
      left: 50%; top: 0;
      width: 4px; height: 100%;
      background: #fff;
      transform-origin: center;
      image-rendering: pixelated;
    }
    #siClose::before { transform: translateX(-50%) rotate(45deg); }
    #siClose::after  { transform: translateX(-50%) rotate(-45deg); }

    /* Contenu — dessous la croix, ne la recouvre plus (z-index inférieur) */
    #siCenter {
      position: absolute; inset: 0;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center; gap: 16px;
      text-align: center;
      padding: 56px 16px 24px; /* espace sous la croix */
      box-sizing: border-box;
      z-index: 1;
    }

    #siSupport {
      font-family: 'vt323', monospace; font-size: 28px;
      color: #fff; background: transparent;
      border: 2px solid #fff; padding: 8px 16px; cursor: pointer;
      touch-action: manipulation;
    }

    #siThanks {
      color: #bbb; font-family: 'vt323', monospace; font-size: 18px; opacity: .85;
    }
  </style>
</head>
<body>

<!-- ===== Interstitiel : fond noir + croix pixel (centrée en haut) + “SOUTENIR LE JEU” ===== -->
<div id="supportInterstitial" aria-hidden="true">
  <button id="siClose" aria-label="Fermer"></button>
  <div id="siCenter">
    <button id="siSupport">SOUTENIR LE JEU</button>
    <div id="siThanks">Merci pour le soutien ❤️</div>
  </div>
</div>

<!-- Firebase (compat pour usage direct en <script>) -->
<script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore-compat.js"></script>
<script>
  /* ====== CONFIGURATION FIREBASE (TES VALEURS) ====== */
  const firebaseConfig = {
    apiKey: "AIzaSyAwQKptiehYxigqjxOwRvDBv7gkdYCcRAk",
    authDomain: "get-this-money.firebaseapp.com",
    projectId: "get-this-money",
    storageBucket: "get-this-money.firebasestorage.app",
    messagingSenderId: "529212382767",
    appId: "1:529212382767:web:2e723af6f81bad47a730da"
  };

  let firebaseReady = false;
  let db = null;

  (function initFirebaseSafe(){
    try {
      firebase.initializeApp(firebaseConfig);
      db = firebase.firestore();
      firebaseReady = true;
      console.log('[Firebase] OK');
    } catch(e){
      console.warn('[Firebase] Non initialisé. Le jeu continue sans global score.', e);
    }
  })();

  // Sauvegarder un score (non bloquant si Firebase KO)
  async function saveScore(player, score) {
    if (!firebaseReady || !db) return;
    try {
      await db.collection("scores").add({
        player: player,
        score: score,
        createdAt: firebase.firestore.FieldValue.serverTimestamp()
      });
    } catch (e) {
      console.warn('[Firebase] saveScore erreur:', e);
    }
  }

  // Lire le meilleur score global (retourne 0 si indisponible)
  async function getBestGlobalScore() {
    if (!firebaseReady || !db) return 0;
    try {
      const snap = await db.collection("scores")
        .orderBy("score", "desc")
        .limit(1)
        .get();
      if (!snap.empty) {
        return snap.docs[0].data().score || 0;
      }
      return 0;
    } catch (e) {
      console.warn('[Firebase] getBestGlobalScore erreur:', e);
      return 0;
    }
  }
</script>

<script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
<script>
// ======= Réglage unique de l'espacement des lignes =======
const STATS_LINE_SPACING = 0.55;
// =========================================================

const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

// Marge visuelle (gardée pour compat, plus utilisée pour le support dans Game Over)
const SAFE_BOTTOM_MOBILE = 96;

// Résolution virtuelle fixe (comme PC)
const spriteScale = 1;
const hudScale = 1;
const baseButtonScale = 0.25;
const gameOverImageScale = 0.3;

const GAME_W = 400;
const GAME_H = 600;

const config = {
  type: Phaser.WEBGL,
  scale: {
    // PC: FIT (inchangé). Mobile: pleine hauteur, largeur ajustée au ratio, collé en haut.
    mode: isMobile ? Phaser.Scale.HEIGHT_CONTROLS_WIDTH : Phaser.Scale.FIT,
    autoCenter: isMobile ? Phaser.Scale.CENTER_HORIZONTALLY : Phaser.Scale.CENTER_BOTH,
    width: GAME_W,
    height: GAME_H
  },
  render: { antialias: true, roundPixels: true },
  physics: { default: 'arcade', arcade: { debug: false } },
  scene: [IntroScene, MainScene]
};

let game = new Phaser.Game(config);
let musicStarted = false, backMusic = null, gameOverSoundRef = null;

// Best score
let bestLocalScore = parseInt(localStorage.getItem('bestScore') || '0', 10);

// Refs
let statsContainer = null, scoreLineText = null, timeLineText = null, bestLocalText = null, globalLineText = null;
let player, cursors, obstacles, bonuses, background;
let score = 0, scoreText, levelText, levelDisplay, healthLabel, healthHearts, timerText;
let gameOverImage, finalScoreText, overlay, restartButton;
/* supportButton retiré de l'écran Game Over */
let supportButton = null;

let level = 1, lives = 3, gameOver = false;
let obstacleSpeed = 120, bonusSpeed = 200, roadScrollSpeed = 2;
let spawnObstacleEvent, spawnBonusEvent, timer = 0, timerEvent, levelTween, levelTimer;
const levelThresholds = [0, 250, 600, 1100, 1750, 2450, 3400, 4500];

/* ----- Mobile retry zone (optionnel) ----- */
let mobileRetryZone = null;

/* ====== Interstitiel : réglage de fréquence ======
   Pour tester maintenant : SI_EVERY_N = 1 (à chaque fin de partie)
   Plus tard : passe à 3 pour "toutes les 3 parties" */
const SI_EVERY_N = 1;  // <<< règle ici (1 = chaque partie, 3 = toutes les 3 parties)
let gamesPlayed = parseInt(localStorage.getItem('gamesPlayed') || '0', 10);
function shouldShowSupportInterstitial() {
  return SI_EVERY_N > 0 && ((gamesPlayed + 1) % SI_EVERY_N === 0); // +1 car on incrémente au endGame()
}

/* Interstitiel : ouverture / fermeture */
function showSupportInterstitial(next) {
  const el = document.getElementById('supportInterstitial');
  const closeBtn = document.getElementById('siClose');
  const supportBtn = document.getElementById('siSupport');
  if (!el || !closeBtn || !supportBtn) { next?.(); return; }

  let closed = false; // évite les doubles appels (click + touchend)

  function openPayPal(e) {
    e?.preventDefault?.();
    const url = 'https://paypal.me/eightenergyworld';
    try {
      window.open(url, '_blank', 'noopener,noreferrer');
    } catch (err) {
      console.warn('Impossible d’ouvrir PayPal dans un nouvel onglet', err);
    }
  }
  function onClose(e) {
    if (closed) return;
    closed = true;
    e?.preventDefault?.();
    el.style.display = 'none';
    // Nettoyage des handlers
    closeBtn.removeEventListener('click', onClose);
    closeBtn.removeEventListener('touchend', onClose);
    supportBtn.removeEventListener('click', openPayPal);
    supportBtn.removeEventListener('touchend', openPayPal);
    // Ensuite, Game Over
    next?.();
  }

  // Fermer via croix (PC & Mobile)
  closeBtn.addEventListener('click', onClose);
  closeBtn.addEventListener('touchend', onClose, {passive:true});

  // Ouvrir PayPal (PC & Mobile)
  supportBtn.addEventListener('click', openPayPal);
  supportBtn.addEventListener('touchend', openPayPal, {passive:true});

  // Fermer via Échap
  function onKey(e){ if (e.key === 'Escape') onClose(e); }
  document.addEventListener('keydown', onKey, { once:true });

  // Afficher
  el.style.display = 'block';
}

function supportsWebP(){
  const c=document.createElement('canvas');
  return !!(c.getContext && c.getContext('2d')) ? c.toDataURL('image/webp').indexOf('data:image/webp')===0 : false;
}

// ---------- Intro ----------
function IntroScene(){ Phaser.Scene.call(this,{key:'IntroScene'}); }
IntroScene.prototype = Object.create(Phaser.Scene.prototype); IntroScene.prototype.constructor = IntroScene;
IntroScene.prototype.preload = function(){
  this.load.image('introWebP','image/intro.webp');
  this.load.image('introJPG','image/intro.jpg');
  this.load.image('startBtn', supportsWebP() ? 'image/start.webp' : 'image/start.png');
  this.load.audio('back','son/back.mp3');
  this.load.audio('back_intro','son/back_intro.mp3');
};
IntroScene.prototype.create = function(){
  const { width, height } = this.scale;
  const key = supportsWebP() ? 'introWebP' : 'introJPG';
  this.add.image(width/2, height/2, key).setDisplaySize(width, height);

  this.introMusic = this.sound.add('back_intro', { loop:true, volume:0.2 }); this.introMusic.play();
  const unlock = () => { this.sound.unlock(); if(!this.introMusic.isPlaying) this.introMusic.play();
    window.removeEventListener('pointerdown', unlock); window.removeEventListener('touchstart', unlock); };
  window.addEventListener('pointerdown', unlock); window.addEventListener('touchstart', unlock);

  const startButton = this.add.image(width/2, height*0.8, 'startBtn').setOrigin(0.5).setInteractive({useHandCursor:true}).setScale(baseButtonScale*spriteScale);
  this.tweens.add({ targets:startButton, scale:baseButtonScale*spriteScale*1.2, yoyo:true, repeat:-1, ease:'Sine.easeInOut', duration:600 });
  startButton.on('pointerdown', () => { if(this.introMusic?.isPlaying) this.introMusic.stop(); this.cameras.main.fadeOut(500,0,0,0);
    this.time.delayedCall(500, () => this.scene.start('MainScene')); });
};

// ---------- Main ----------
function MainScene(){ Phaser.Scene.call(this,{key:'MainScene'}); }
MainScene.prototype = Object.create(Phaser.Scene.prototype); MainScene.prototype.constructor = MainScene;

MainScene.prototype.preload = function(){
  const isRetina = window.devicePixelRatio > 1, useWebP = supportsWebP(), ext = useWebP ? 'webp' : 'png';
  this.load.image('player',`image/player${isRetina?'@2x':''}.${ext}`);
  this.load.image('obstacle',`image/obstacle${isRetina?'@2x':''}.${ext}`);
  this.load.image('bonus',`image/bonus${isRetina?'@2x':''}.${ext}`);
  this.load.image('road',`image/road${isRetina?'@2x':''}.${ext}`);
  this.load.image('vie',`image/vie${isRetina?'@2x':''}.${ext}`);
  this.load.image('retryBtn', supportsWebP() ? 'image/retry.webp' : 'image/retry.png');
  this.load.image('gameOverImg', supportsWebP() ? 'image/game_over.webp' : 'image/game_over.png');
  this.load.audio('bonus','son/bonus.wav');
  this.load.audio('obstacle','son/obstacle.wav');
  this.load.audio('gameover','son/gameover.mp3');
  this.load.audio('lvl','son/lvl.wav');
  this.load.bitmapFont('vt323','fonts/vt323_0.png','fonts/vt323.fnt');
};

MainScene.prototype.create = function(){
  const w = this.scale.width, h = this.scale.height;
  const cx = w/2, cy = h/2;

  background = this.add.tileSprite(cx, cy, w, h*2, 'road').setDepth(0);

  // Positions identiques PC
  player = this.physics.add.sprite(200,400,'player').setDisplaySize(40*spriteScale,40*spriteScale).setCollideWorldBounds(true);
  obstacles = this.physics.add.group(); bonuses = this.physics.add.group();

  scoreText = this.add.bitmapText(10,5,'vt323','SCORE: 0',28*hudScale).setDepth(11);
  timerText = this.add.bitmapText(200,5,'vt323','TEMPS: 0',28*hudScale).setOrigin(0.5,0).setDepth(11);
  levelText = this.add.bitmapText(200,50,'vt323','NIVEAU: 1',28*hudScale).setOrigin(0.5).setDepth(11);
  healthLabel = this.add.bitmapText(300,5,'vt323','VIE:',28*hudScale).setDepth(11);

  healthHearts = this.add.group(); updateHearts.call(this);
  levelDisplay = this.add.bitmapText(200,300,'vt323','',48).setOrigin(0.5).setDepth(20);
  overlay = this.add.rectangle(200,300,400,600,0x000000,0.0).setDepth(49).setVisible(false);

  gameOverImage = this.add.image(200,220,'gameOverImg').setOrigin(0.5).setDepth(50).setScale(gameOverImageScale*spriteScale).setAlpha(0).setVisible(false).disableInteractive();
  finalScoreText = this.add.bitmapText(200,340,'vt323','',36).setOrigin(0.5).setDepth(50);

  /* IMPORTANT : Retry au-dessus de tout le reste */
  restartButton = this.add.image(200,424,'retryBtn')
    .setOrigin(0.5).setDepth(70).setVisible(false)
    .setInteractive({useHandCursor:true})
    .setScale(baseButtonScale*spriteScale);
  restartButton.on('pointerdown', () => resetGame.call(this)); // PC et mobile OK
  this.tweens.add({ targets:restartButton, scale:baseButtonScale*spriteScale*1.2, yoyo:true, repeat:-1, ease:'Sine.easeInOut', duration:600 });

  cursors = this.input.keyboard.createCursorKeys();
  spawnObstacleEvent = this.time.addEvent({ delay:1200, callback:spawnObstacle, callbackScope:this, loop:true });
  spawnBonusEvent = this.time.addEvent({ delay:2000, callback:spawnBonus, callbackScope:this, loop:true });
  timerEvent = this.time.addEvent({ delay:1000, callback:()=>{ timer++; timerText.setText('TEMPS: ' + timer); }, loop:true });

  this.physics.add.overlap(player, obstacles, hitObstacle, null, this);
  this.physics.add.overlap(player, bonuses, collectBonus, null, this);

  this.input.on('pointermove', p => { if(!gameOver){ player.x = p.x; player.y = p.y - 50; } });

  if (!musicStarted){ backMusic = this.sound.add('back',{ loop:true, volume:0.15 }); backMusic.play(); musicStarted = true; }
  this.bonusSound = this.sound.add('bonus',{ volume:0.15 });
  this.obstacleSound = this.sound.add('obstacle',{ volume:0.2 });
  gameOverSoundRef = this.sound.add('gameover',{ volume:0.7 });
  this.levelSound = this.sound.add('lvl',{ volume:0.5 });

  // (sécurité) listeners existants
  this.scale.on('resize', () => placeSupportBottom(this));
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', () => placeSupportBottom(this));
    window.visualViewport.addEventListener('scroll', () => placeSupportBottom(this));
  } else {
    window.addEventListener('resize', () => placeSupportBottom(this));
  }
};

MainScene.prototype.update = function(time, delta){
  if (gameOver) return;
  background.tilePositionY -= roadScrollSpeed * (delta/16.66);

  const move = 250;
  if (cursors.left.isDown) player.x -= move*(delta/1000); else if (cursors.right.isDown) player.x += move*(delta/1000);
  if (cursors.up.isDown) player.y -= move*(delta/1000); else if (cursors.down.isDown) player.y += move*(delta/1000);

  obstacles.children.iterate(o => { o.y += obstacleSpeed*(delta/1000); });
  bonuses.children.iterate(b => { b.y += bonusSpeed*(delta/1000); });

  obstacles.getChildren().forEach(o => { if (o.y > 560) o.destroy(); });
  bonuses.getChildren().forEach(b => { if (b.y > 560) b.destroy(); });

  obstacleSpeed = 120 + level*15; bonusSpeed = 200 + level*10;

  const nl = getLevelFromScore(score);
  if (nl !== level){
    level = nl; roadScrollSpeed = 2 + (level-1)*0.5;
    levelText.setText('NIVEAU:  ' + level);
    showLevelMessage(this);
    adjustSpawnRates.call(this);
  }
  scoreText.setText('SCORE: ' + score);
};

function getLevelFromScore(s){ let l=1; for(let i=1;i<levelThresholds.length;i++){ if(s>=levelThresholds[i]) l=i+1; } return l; }
function adjustSpawnRates(){
  if (spawnBonusEvent) spawnBonusEvent.reset({
    delay: Math.max(500, 2500 - level*300),
    callback: spawnBonus,
    callbackScope: this,
    loop: true
  });
  if (spawnObstacleEvent) spawnObstacleEvent.reset({
    delay: Math.max(400, 1200 - level*100),
    callback: spawnObstacle,
    callbackScope: this,
    loop: true
  });
}
function showLevelMessage(scene){ if(scene.levelSound) scene.levelSound.play(); levelDisplay.setText('NIVEAU : ' + level);
  if(levelTween) levelTween.stop(); if(levelTimer) levelTimer.remove(false);
  levelTween = scene.tweens.add({ targets:levelDisplay, scaleX:1.5, scaleY:1.5, duration:300, yoyo:true });
  levelTimer = scene.time.addEvent({ delay:1500, callback:()=>levelDisplay.setText('') });
}
function spawnObstacle(){
  const w = this.scale.width;
  obstacles.create(Phaser.Math.Between(50, w-50), 50, 'obstacle').setDisplaySize(40*spriteScale,40*spriteScale).setDepth(1);
}
function spawnBonus(){
  const w = this.scale.width;
  bonuses.create(Phaser.Math.Between(50, w-50), 50, 'bonus').setDisplaySize(40*spriteScale,40*spriteScale).setDepth(1);
}
function collectBonus(p,b){ b.destroy(); score+=50; this.bonusSound.play(); }
function hitObstacle(p,o){ o.destroy(); lives--; this.obstacleSound.play(); updateHearts.call(this); animateHealthBar.call(this); if(lives<=0) endGame.call(this); }
function animateHealthBar(){ healthHearts.children.each(h => { this.tweens.add({ targets:h, scaleX:h.scaleX*1.15, scaleY:h.scaleY*1.15, yoyo:true, duration:150, ease:'Power2' }); }); }

/* Cœurs :
   - PC : position fixe (startX=345, spacing=19, sc=0.4, y=22)
   - Mobile : adaptatif (légèrement plus bas pour l’alignement) */
function updateHearts(){
  healthHearts.clear(true,true);
  if (isMobile){
    const sc = 0.6*spriteScale, heartW = 32*sc;
    const available = this.scale.width - (healthLabel.x + healthLabel.width + 20);
    let spacing = heartW*1.1; if (lives*spacing>available) spacing = available/Math.max(1,lives);
    const startX = healthLabel.x + healthLabel.width + 10;
    const midY = healthLabel.y + (healthLabel.height*0.5);
    const offsetY = 4; // ⬇️ léger décalage vers le bas sur mobile

    for (let i=0;i<lives;i++){
      let h = this.add.image(startX + (i*spacing), midY + offsetY, 'vie')
        .setOrigin(0.5).setScale(sc).setDepth(11);
      healthHearts.add(h);
    }
  } else {
    const startX=345, spacing=19, sc=0.4, y=22;
    for (let i=0;i<lives;i++){
      let h = this.add.image(startX + (i*spacing), y, 'vie')
        .setOrigin(0.5).setScale(sc).setDepth(11);
      healthHearts.add(h);
    }
  }
}

/* ==== (héritage) placeSupportBottom : no-op sans supportButton ==== */
function placeSupportBottom(scene){
  if (!supportButton) return;
  const canvasH = scene.scale.height;
  const bounds = supportButton.getBounds();
  const halfH = bounds.height / 2;
  const safeMargin = isMobile ? SAFE_BOTTOM_MOBILE : 40;
  let y = canvasH - safeMargin - halfH;
  supportButton.setY(y);
}

/* === Construction UI Game Over (SANS "SOUTENIR") === */
function showGameOverUI() {
  const centerX = this.scale.width/2;

  gameOverImage.setVisible(true).setPosition(200,220);
  this.tweens.add({ targets:gameOverImage, alpha:1, duration:500, ease:'Sine.easeOut' });

  /* Retry visible et au-dessus */
  restartButton.setVisible(true).setDepth(70).setPosition(200,424);

  if (score > bestLocalScore){ bestLocalScore = score; localStorage.setItem('bestScore', String(bestLocalScore)); }

  const statsSize = 28;
  const step = Math.max(1, statsSize * STATS_LINE_SPACING);

  scoreLineText = this.add.bitmapText(0, -step, 'vt323', 'SCORE : ' + score, statsSize).setOrigin(0.5);
  timeLineText  = this.add.bitmapText(0,  0,    'vt323', 'TEMPS : ' + timer + 's', statsSize).setOrigin(0.5);
  bestLocalText = this.add.bitmapText(0,  step, 'vt323', 'MEILLEUR SCORE (TOI) : ' + bestLocalScore, statsSize).setOrigin(0.5);

  // Placeholder pour le global (sera mis à jour après lecture Firestore)
  globalLineText= this.add.bitmapText(0,  step*2,'vt323', 'MEILLEUR SCORE (TOUS) : ...', statsSize).setOrigin(0.5);

  const bottomOfOver = gameOverImage.y + gameOverImage.displayHeight/1.7;
  const topOfRetry   = restartButton.y - restartButton.displayHeight/2;

  // Décalage vers le haut d'une demi-ligne pour compenser la ligne en plus
  const midY = ((bottomOfOver + topOfRetry) / 2) - (step / 2);

  if (statsContainer) statsContainer.destroy();
  statsContainer = this.add.container(centerX, midY, [
    scoreLineText, timeLineText, bestLocalText, globalLineText
  ]).setDepth(50);

  /* ==== Firebase : enregistrement + meilleur score (tous) ==== */
  saveScore('Joueur', score);
  getBestGlobalScore().then(bestGlobal => {
    if (globalLineText) {
      globalLineText.setText('MEILLEUR SCORE (TOUS) : ' + bestGlobal);
    }
  });
}

/* === Fin de partie : interstitiel PUIS Game Over === */
function endGame(){
  if (gameOver) return; gameOver = true;
  if (backMusic?.isPlaying) backMusic.stop();
  if (gameOverSoundRef) gameOverSoundRef.play();
  this.physics.pause(); player.setTint(0xff0000);
  spawnObstacleEvent.remove(false); spawnBonusEvent.remove(false);
  if (timerEvent) timerEvent.remove(false); if (levelTween) levelTween.stop(); if (levelTimer) levelTimer.remove(false);
  levelDisplay.setText(''); overlay.setVisible(true);

  // Compter la partie finie
  gamesPlayed = (gamesPlayed|0) + 1;
  localStorage.setItem('gamesPlayed', String(gamesPlayed));

  // Affiche l’interstitiel selon la fréquence, puis Game Over
  if (shouldShowSupportInterstitial()) {
    // capture du this de la scène via l'arrow function
    showSupportInterstitial(() => { showGameOverUI.call(this); });
  } else {
    showGameOverUI.call(this);
  }
}

function resetGame(){
  score=0; lives=3; level=1; timer=0; gameOver=false;
  obstacleSpeed=120; bonusSpeed=200; roadScrollSpeed=2;
  scoreText.setText('SCORE: 0'); timerText.setText('TEMPS: 0'); levelText.setText('NIVEAU: 1');
  finalScoreText.setText('');
  gameOverImage.setVisible(false).setAlpha(0); overlay.setVisible(false); restartButton.setVisible(false);

  if (mobileRetryZone) { mobileRetryZone.destroy(); mobileRetryZone = null; }

  if (supportButton){ supportButton.destroy(); supportButton=null; } // (sécurité)
  if (statsContainer){ statsContainer.destroy(); statsContainer=null; }
  if (scoreLineText){ scoreLineText.destroy(); scoreLineText=null; }
  if (timeLineText){ timeLineText.destroy(); timeLineText=null; }
  if (bestLocalText){ bestLocalText.destroy(); bestLocalText=null; }
  if (globalLineText){ globalLineText.destroy(); globalLineText=null; }

  player.clearTint(); player.setPosition(200,400);
  obstacles.clear(true,true); bonuses.clear(true,true);
  this.physics.resume();
  timerEvent = this.time.addEvent({ delay:1000, callback:()=>{ timer++; timerText.setText('TEMPS: ' + timer); }, loop:true });
  spawnObstacleEvent = this.time.addEvent({ delay:1200, callback:spawnObstacle, callbackScope:this, loop:true });
  spawnBonusEvent = this.time.addEvent({ delay:2000, callback:spawnBonus, callbackScope:this, loop:true });
  updateHearts.call(this);
  if (gameOverSoundRef?.isPlaying) gameOverSoundRef.stop();
  if (backMusic) backMusic.play();

  restartButton.setInteractive({useHandCursor:true});
}
</script>
</body>
</html>
